{"version":3,"sources":["Header.js","App.js","index.js"],"names":["Header","props","title","Toolbar","sx","borderBottom","borderColor","Typography","component","variant","color","align","noWrap","flex","Test","handleScan","data","state","resultList","includes","setState","prevState","result","console","log","handleError","err","error","bind","controls","this","stop","codeReader","BrowserMultiFormatReader","BrowserCodeReader","listVideoInputDevices","videoInputDevices","selectedDeviceId","length","deviceId","previewElem","document","querySelector","resultDisplay","decodeFromVideoDevice","getText","innerHTML","BrowserMultiFormatOneDReader","id","style","display","alignItems","justifyContent","Component","rootElement","getElementById","ReactDOM","render","App"],"mappings":"mOAkCeA,MA7Bf,SAAgBC,GACd,IAAQC,EAAUD,EAAVC,MAER,OACE,cAAC,WAAc,UACb,cAACC,EAAA,EAAO,CAACC,GAAI,CAAEC,aAAc,EAAGC,YAAa,WAAY,SACvD,cAACC,EAAA,EAAU,CACTC,UAAU,KACVC,QAAQ,KACRC,MAAM,UACNC,MAAM,SACNC,QAAM,EACNR,GAAI,CAAES,KAAM,GAAI,SAEfX,OAQX,E,QCtBMY,EAAI,kDAEN,WAAYb,GAAQ,IAAD,EAUD,OAVC,qBACf,cAAMA,IAYVc,WAAa,SAACC,GACNA,IACK,EAAKC,MAAMC,WAAWC,SAASH,KAChC,EAAKI,UAAS,SAAAC,GAAS,MAAK,CACxBC,OAAQN,EACRE,WAAW,GAAD,mBAAMG,EAAUH,YAAU,CAAEF,IACzC,IACDO,QAAQC,IAAI,EAAKP,MAAMK,QACvBC,QAAQC,IAAI,EAAKP,MAAMC,aAInC,EAAE,EAEFO,YAAc,SAACC,GACXH,QAAQI,MAAMD,EAClB,EA1BI,EAAKT,MAAQ,CACTK,OAAQ,YACRJ,WAAY,IAGhB,EAAKO,YAAc,EAAKA,YAAYG,KAAK,gBACzC,EAAKb,WAAa,EAAKA,WAAWa,KAAK,gBACvC,EAAKC,SAAS,CAClB,CAoGC,OApGA,gGAoBD,sGAEqD,OADjDC,KAAKD,SAASE,OACRC,EAAa,IAAIC,IAA2B,EAAD,OAEjBC,IAAkBC,wBAAwB,KAAD,EAezE,OAfMC,EAAiB,OAIfC,EADJD,EAAkBE,QAAU,EACLF,EAAkB,GAAGG,SAErBH,EAAkB,GAAGG,SAGhDhB,QAAQC,IAAI,sCAAD,OAAuCa,IAE5CG,EAAcC,SAASC,cAAc,qCACrCC,EAAgBF,SAASC,cAAc,WAG7C,UACiBV,EAAWY,sBAAsBP,EAAkBG,GAAa,SAAClB,EAAQK,EAAOE,GAIzFP,IACAC,QAAQC,IAAIF,EAAOuB,WACnBF,EAAcG,WAAS,eAAYxB,GAE3C,IAAG,KAAD,GARFO,SAAQ,wDASX,kDAjDA,IAiDA,gFAED,sGACyD,OAA/CG,EAAa,IAAIe,IAA+B,EAAD,OAErBb,IAAkBC,wBAAwB,KAAD,EAezE,OAfMC,EAAiB,OAIfC,EADJD,EAAkBE,QAAU,EACLF,EAAkB,GAAGG,SAErBH,EAAkB,GAAGG,SAGhDhB,QAAQC,IAAI,sCAAD,OAAuCa,IAE5CG,EAAcC,SAASC,cAAc,qCACrCC,EAAgBF,SAASC,cAAc,WAG7C,UACiBV,EAAWY,sBAAsBP,EAAkBG,GAAa,SAAClB,EAAQK,EAAOE,GAIzFP,IACAC,QAAQC,IAAIF,EAAOuB,WACnBF,EAAcG,WAAS,eAAYxB,GAE3C,IAAG,KAAD,GARFO,SAAQ,mDAUX,kDA/BA,IA+BA,oBAED,WACI,OACI,qCACI,cAAC,EAAM,CAAC3B,MAAM,UACd,qBAAK8C,GAAG,2BAA2BC,MAAO,CACtCC,QAAS,OACTC,WAAY,SACZC,eAAgB,UAClB,SAEE,4BAKJ,mBAAGJ,GAAG,aAGlB,KAAC,EAjHK,CAASK,aAmHJvC,ICnHTwC,EAAcb,SAASc,eAAe,QAC5CC,IAASC,OACP,cAAC,aAAU,UACT,cAACC,EAAG,MAENJ,E","file":"static/js/main.90285c23.chunk.js","sourcesContent":["import * as React from 'react';\nimport PropTypes from 'prop-types';\nimport Toolbar from '@mui/material/Toolbar';\nimport Typography from '@mui/material/Typography';\n\nfunction Header(props) {\n  const { title } = props;\n\n  return (\n    <React.Fragment>\n      <Toolbar sx={{ borderBottom: 1, borderColor: 'divider' }}>\n        <Typography\n          component=\"h2\"\n          variant=\"h5\"\n          color=\"inherit\"\n          align=\"center\"\n          noWrap\n          sx={{ flex: 1 }}\n        >\n          {title}\n        </Typography>\n\n        \n      </Toolbar>\n      \n    </React.Fragment>\n  );\n}\n\nHeader.propTypes = {\n\n  title: PropTypes.string.isRequired,\n};\n\nexport default Header;","\nimport React, { Component, useEffect } from \"react\";\nimport Header from \"./Header\";\nimport { BrowserCodeReader, BrowserMultiFormatReader, BrowserMultiFormatOneDReader } from '@zxing/browser';\n\nclass Test extends Component {\n    controls;\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            result: \"No result\",\n            resultList: []\n        };\n\n        this.handleError = this.handleError.bind(this);\n        this.handleScan = this.handleScan.bind(this);\n        this.controls;\n    }\n\n    handleScan = (data) => {\n        if (data) {\n            if (!this.state.resultList.includes(data)) {\n                this.setState(prevState => ({\n                    result: data,\n                    resultList: [...prevState.resultList, data]\n                }));\n                console.log(this.state.result);\n                console.log(this.state.resultList);\n            }\n            // this.setState({result: data});\n        }\n    };\n\n    handleError = (err) => {\n        console.error(err);\n    };\n\n    async componentDidUpdate(){\n        this.controls.stop();\n        const codeReader = new BrowserMultiFormatReader();\n\n        const videoInputDevices = await BrowserCodeReader.listVideoInputDevices();\n\n        // choose your media device (webcam, frontal camera, back camera, etc.)\n        if (videoInputDevices.length >= 2) {\n            var selectedDeviceId = videoInputDevices[1].deviceId;\n        } else {\n            var selectedDeviceId = videoInputDevices[0].deviceId;\n        }\n\n        console.log(`Started decode from camera with id ${selectedDeviceId}`);\n\n        const previewElem = document.querySelector('#test-area-qr-code-webcam > video');\n        const resultDisplay = document.querySelector('#result');\n\n\n        // you can use the controls to stop() the scan or switchTorch() if available\n        controls = await codeReader.decodeFromVideoDevice(selectedDeviceId, previewElem, (result, error, controls) => {\n            // use the result and error values to choose your actions\n            // you can also use controls API in this scope like the controls\n            // returned from the method.\n            if (result) {\n                console.log(result.getText())\n                resultDisplay.innerHTML += `<br/>${result}`\n            }\n        });\n    }\n\n    async componentDidMount() {\n        const codeReader = new BrowserMultiFormatOneDReader();\n\n        const videoInputDevices = await BrowserCodeReader.listVideoInputDevices();\n\n        // choose your media device (webcam, frontal camera, back camera, etc.)\n        if (videoInputDevices.length >= 2) {\n            var selectedDeviceId = videoInputDevices[1].deviceId;\n        } else {\n            var selectedDeviceId = videoInputDevices[0].deviceId;\n        }\n\n        console.log(`Started decode from camera with id ${selectedDeviceId}`);\n\n        const previewElem = document.querySelector('#test-area-qr-code-webcam > video');\n        const resultDisplay = document.querySelector('#result');\n\n\n        // you can use the controls to stop() the scan or switchTorch() if available\n        controls = await codeReader.decodeFromVideoDevice(selectedDeviceId, previewElem, (result, error, controls) => {\n            // use the result and error values to choose your actions\n            // you can also use controls API in this scope like the controls\n            // returned from the method.\n            if (result) {\n                console.log(result.getText())\n                resultDisplay.innerHTML += `<br/>${result}`\n            }\n        });\n\n    }\n\n    render() {\n        return (\n            <>\n                <Header title='Pay!t' />\n                <div id=\"test-area-qr-code-webcam\" style={{\n                    display: 'flex',\n                    alignItems: 'center',\n                    justifyContent: 'center',\n                }}>\n\n                    <video>\n\n                    </video>\n\n                </div>\n                <p id=\"result\"></p>\n            </>\n        );\n    }\n}\nexport default Test;\n","import { StrictMode } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n  rootElement\n);\n"],"sourceRoot":""}